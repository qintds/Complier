// Description
import Base

/* multiple line
description
*/

and as
break
class continue
elif else
func for False
if import
or
pass
return
while
True
None


《我拥有的所有》
有些不安
也许是因为我太想你
不要声张
爱就是要潜藏在心底

可是我 纠结了许久还是放不下
只能够 闭上眼 逃跑

多少时光
在欢笑悲伤中全忘掉
留下遗憾
可人生本来不就这样

你说以后 分开是不是比现在更好
只能够 闭上眼 祷告

我衷心的请求你做我唯一的皇后
不要去想以后那些不存在的借口
我拥有的所有
去弥补你的伤口
只要你陪我到最后

我困在迷宫中寻找着唯一的出口
是你在黑暗中给了我继续的理由
我拥有的所有
都是你给的温柔
请求你陪我到最后


建树的时候只要转换四种基本类型即可
其他直接保留就好

《口袋》
他的卫衣上 有一个口袋
你的衬衫上 有两个口袋
她的外套上 有三个口袋
为什么我的背心 没有口袋

他的朋友夸他 有一点可爱
你的朋友夸你 有两点可爱
她的朋友夸她 有三点可爱
我没有什么朋友 也不可爱

也许人生本来就不公平
有些人在旅行
我还在努力
但是每个人都是独特风景
你也不需要为这厚此薄彼

他的背包里 有一个苹果
你的背包里 有两个苹果
她的背包里 有三个苹果
我虽然有背包 但没苹果

其实这些东西 全都是枷锁
总是偶尔让人 感到了疑惑
靠着个人努力 去慢慢挣脱
以后你过的生活 会更洒脱



粤语

轻挽起你的手臂
将欢笑藏于一起

不想见那些伤悲
清空心境才去稳你

愿你知 沿途藏着些意外
望你知 难完全避开障碍
但你知 能前来人生这戏台
已经足够令二人愉快

不追究人生意义
伤感也无可改变
一切事情都体验
聆听迷人故事

当钟声来到面前
失去但仍可入眠
身边有人可相牵
亦令人非常满意


 赋值时LEFTSIDE 对第一个进行赋值
 左递归不断取值，只是对最上层赋值，因此下面的直接取值就行


论文说明解释器和编译器的选择 llvm也写上


对现状的分析 作为论文的背景




海边住着一个老人
诉说着他的一生
告诉他的孩子
曾遇到什么人

他拿起手中铅笔
记起他的日记
享受着黄昏的余温



《小雪》
夏天的阳光
轻轻铺在窗台上
你的笑容
吸引住我的眼光
下课钟声响
又拾起丢失的幻想
你向我一看
我反而紧张的一闪

我们牵手在夏天的夜晚
. . . . . . . . . .10
躺在操场一起看星空模样
. . . . . . . . . . .11
轻声在你耳边说喜欢你
. . . . . . . . . .10
却又看到男生传来的短信
. . . . . . . . . . .11

感受着
清晨拂过的春风
如你的笑容
轻起一丝丝律动
在我的心中
情不自禁的温柔
你无动于衷
可我是一个女生

高考的收场




问题定位
换行 归约问题
分号和换行符的冲突

没有应该不应该，只有你自己喜欢不喜欢。JavaScript 语法长得 C-like 不代表它本质上和 C 是一类语言，所有直觉性的 “当然应该加分号” 都是保守的、未经深入思考的草率结论。后来新设计的语言里可选分号的多得去了，光是 “可以加分号但是大家都不加” 的语言就有：Go, Scala, Ruby, Python, Swift, Groovy...
至于说 “很难总结什么时候加不加”，其实真的很简单。真正会导致上下行解析出问题的 token 有 5 个：括号()，方括号[]，正则开头的斜杠/，加号+，减号-。我还从没见过实际代码中用正则、加号、减号作为行首的情况，所以总结下来就是一句话：一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要。其实即使是这两种情况，在实际代码中也颇为少见。

注：函数栈开销是一个绝对值，但也算是一个“相对“概念，一个非量化的理性分析是，内部逻辑越简单的函数，栈开销的影响越大，因为函数的出入栈指令占整个函数体指令的比重较大。
很多情况下，代码的易维护性是一个比性能开销更加重要的因素，因此，只要实际应用中不会造成函数栈溢出，我个人是更建议采用递归函数法的。
---------------------
作者：bobbypollo
来源：CSDN
原文：https://blog.csdn.net/bobbypollo/article/details/79891556
版权声明：本文为博主原创文章，转载请附上博文链接！

1、递归和非递归（用栈）

非递归（用栈），也用到栈函数了，和递归就没多大区别了!

每次递归进栈出栈，非递归（用栈）的每次调用栈函数也是进栈出栈。
主要是在非递归（用栈）中，它的栈函数里比递归多了些赋值语句。。。
所以效率上，非递归（用栈）比递归差。

只不过，递归越深，占用栈空间越多。非递归（用栈），占用的栈空间少。
如果，递归的深度还没达到超出栈空间的程度，那么递归比非递归（用栈）好。

如果是非递归（不用栈），当然是非递归最好。

2、个人感觉，大多数的编译器优化手法，基本上大同小异，区别不大。

VC编译的Debug版本和Release版本里，Debug版本的程序生成会比较大。（说的是VC6.0，还没用过vc++2008）



歌词忘了
就重新再写一遍
换个方式
会不会多爱一点
想起了你的笑脸
美好又出现在眼前

我的样子
看起来还是没变
对你相念
却多了不止一点
欢笑回忆全浮现
地铁已到终点

这不是终点 还要些时间
我喜欢下雪 而不是雨天
你就在面前 我看你侧脸
不敢向前

这不是终点 我败给时间
不知所措的忘掉一切
难道你
就不能再多等一点点

这不是终点 还要些时间
昨天的盛典 是一场梦魇
我写的思念 你能否看见
我依然想念

这一场表演 不浪费时间
看似在变脸 燃烧的火焰
深刻的眷恋 从没有转变
请让我展现


链式调用 a.b[c.d()]
b的环境已经是在a内
但c的环境不受影响


AssignableValue -> Variable . AssignableValue
                 | Variable [ Variable ]
                 | Variable [ STRING ]
                 | Variable [ NUM ]
                 | Variable [ NoAssignExp ]
                 | IDENTIFIER

Variable -> AssignableValue
          | Variable . FuncInvocation
          | FuncInvocation
          | SELF
左递归就还好，主要是点调用时，要将左边兄弟节点作为继承属性，传到右侧节点，
从而调用相应的内容，进入的新产生式时也要继续传递该继承属性
主要包括AssignableValue，Variable，FuncInvocation

静态作用域和动态作用域







